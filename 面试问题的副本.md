



# H5新增的属性

```html
<header>头部</header>
<footer>尾部</footer>
<nav>导航栏</nav>
<section>具体的内容</section>
<article>文章</article>
<aside>内容的侧边栏</aside>
placeholder 提示信息
required  是否必须填写
maxlength 最大长度
minlength 最小长度 
step  规定数字间隔
hidden 隐藏
```

# 外边距重叠

```js
外边距重叠就是margin-collapse
在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。
```

# px和em的区别。

```
px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。
浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。
```

# 双向数据绑定的原理

```html
当把一个普通的JavaScript对象传给Vue实例的data选项，Vue将遍历此对象所有的属性，使用Object.defineProperty把这些属性全部转为getter（获取的人）/setter（设置的人）(数据劫持/数据映射)。在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。

所谓的双向绑定是建立在mvvm模型的基础上。
数据层model：应用的数据以及业务的逻辑
视图层view:应用的展示效果，以及各类ui组件库
业务逻辑层:viewModel:将数据和视图联系起来

数据变化后更新视图
视图变化后更新数据

涉及到两个组成部分:
1.监听器(Observe):对所有的数据和属性进行监听
2.解析器(Compiler):对每个元素的节点指令进行扫描和解析，根据指令替换数据，绑定对应的更新函数

具体实现原理
1.new Vue()执行初始化，对data通过Object.defineProperty()进行响应式处理这个过程发生在监听器(Observe)里，每个key都有一个dep实例来储存Watcher实例数组
2.在模板编译时，会对每一个v-开头的关键词进行指令解析，找到动态绑定的数据,从data中获取数据并初始化视图，，这个工程你发生在解析器(Compiler)里，如果是遇到v-model,会监听input事件，更新data中对应的数值。
3.在解析指令的过程中,会定义一个更新函数和Watcher，之后对应的数据发生变化的时候，Watcher会调用更新函数。new Watcher的过程中会读取data的key，从而触发getter依赖收集，将对应的Watcher添加到dep中。
4.将来data中数据一旦发生变化，会首先找到对应的dep，通知所有的watchewr执行更新函数。
```

# vue data为什么是个函数 

```js
data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。
Object是引用数据类型，如果不用function返回，每个组件的data都是内存的同一个地址，一个数据改变了其他也改变了；
```

# axios

```html
axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和node.js中。axios是vue作者推荐使用的网络请求库
- 支持浏览器和node.js
- 支持promise
- 能够拦截`请求和响应`
- 自动转换json数据
```

# 浅拷贝和深拷贝实现方法

```html
浅拷贝：
$.extend(false,{},事件源)
用 = 号赋值引用地址；
for…in( 被循环的对象存在嵌套对象时为浅拷贝)
Object.assign()只有源对象，没有目标对象时为浅拷贝   let obj2 =Object.assign(obj1),出现嵌套情况，那么其对被嵌套对象的行为就成了普通的浅拷贝

深拷贝：
$.extend(true,{},事件源)
for循环(for in)拷贝不存在嵌套时为深拷贝  let obj2 =Object.assign({},obj1)
Object.assign()实现一层深拷贝
slice实现
concat实现
es6的扩展运算符"..."
使用jsON.stringify和jsON.parse实现深拷贝
```

# 判断数组的方法

```JS
arr instancof Array
arr.constructor === Array
Array.isArray(arr)
Array.prototype.isPrototypeOf(arr)
Object.prototype.toString
```

# 什么时候用到vue.nextTick()

```html
在下次DOM更新循环结束之后执行的延时回调，再修改数据之后立即使用该方法，获得更新后的dom。
```

# 函数防抖和节流

```js

```

# computed和watcher的区别

```html
computed是计算属性，必须依赖其他属性值进行计算，有缓存，多次调用只执行一次，并且值发生改变之后才会返回，而且必须有返回值，不能有小括号，不能传参。
watcher是键听属性，监听到值变化的时候执行的回调，在回调中可以进行一些逻辑操作，依赖其他属性动态获取值的时候使用
```

# call apply bind区别

```
call apply区别主要体现在参数的写法上

调用call的对象必须是一个函数function ，第一个参数是一个对象，function的调用者，如果不写的话，会指向全局的windows ，从第二个参数开始，可以接收任意个参数，每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。

调用apply的的对象必须是一个function函数，第一个参数和call的规则一样，第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。

bind 也能改变对象的执行上下文，他会创建一个新的函数，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。
```

# 父子组件加载顺序

```html
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted。
```

# 判断空对象

```js
将对象转为字符串比较(用到JSON.stringify)
var a={};
var b=new Object();
console.log(JSON.stringify(a)=="{}")  //true
console.log(JSON.stringify(b)=="{}")  //true
使用for in循环可以遍历所有属性以次判断对象是否为空对象：
function isEmptyObject(obj){
    for(var key in obj){
        return false
    };
    return true
};

Object.keys() 此方法判断空对象只需要判断返回的数组长度是否为零，为零的话就是空对象。
var data = {};
var arr = Object.keys(data);
console.log(arr.length == 0);//true
```

# vue父子组件通信方式

```js
props
$emit
eventBus 
vuex
provide inject
```

# for in 和for of 的区别

```html
for in 遍历的是键名 for of 遍历的是数值
所以for in 更适合遍历对象，for of 用来遍历数组
```

# 类数组转为数组方法

```js
Array.from(arr)
```

# map set

```html
Map是类似Object的一种键值对集合，区别在于Map的键不仅限于是字符串，其他各种类型的值包括对象都可以成为Map的键
所有的值都可以通过键来获取。
Map 中的键都是唯一的。  set方法添加键值  get方法获取值
查找速度快
由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉。
Set：Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。
add(添加某个值，返回set结构本身) has（返回布尔值） size(集合长度) delete（删除成功返回布尔值） clear(没有返回值) 
```

# 判断数据类型的方法

```js
typeof instanceof 
typeof undefined;
{} instanceof Object; //true
```

# 封装判断数据类型的函数

```js
function getType(obj){
  let type  = typeof obj;
  if(type != "object"){
    return type;
  }
  return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1');
}
```

# null和undefined区别

```html
数据类型不同，null是个对象，undefined 就是unndefined
null代表空，undefined表示没有赋值
```

# promise

```
Promise是异步编程的一种解决方案   有三种状态，分别是：**Pending **（进行中）， ** Resolved **(已完成)，** Rejected ** (已失败)
Promise的all方法提供了并行执行异步操作的能力，在all中所有异步操作结束后才执行回调。
race则是等到第一个Promise改变状态就开始执行回调函数
```

# async  awiat

# Cookie SessionStorage localStroage的区别

```
Cookie: 关闭浏览器就失效了，通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响
sessionStorage：可以自己设置储存的时间，过了时间才失效，用于本地储存一个会话数据，不是一种持久化的本地储存
localStorage用于持久化的本地储存，除非主动删除，否则永远不会过期
```

# 虚拟DOM和differ算法

```html
虚拟DOM就是为了解决浏览器性能问题而被设计出来的若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算.
```

# 事件修饰符

```js
停止冒泡 stop
阻止默认行为 prevent
串联修饰符：stop.prevent
```

# ES6新增语法

```js

```

# 原型链

```js

```

